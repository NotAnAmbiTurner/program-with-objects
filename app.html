<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Notes for Unit 1</title>
  <link rel="stylesheet" href="css.css">
  <!-- I decided I would try to use styles from a .css file, and a <style> element, just to practice in inheritance... then I realized I couldn't get it to work <em> at all</em> :( IT DOES NOTHING!!! - does it just not work on divs? -->
</head>
<!-- I just want to acknowledge up-front that I'm being a bit lazy in that this HTML is (almost) all generated by html_generator.py, which deals with line breaks in 
the input text by deleting them, and doesn't create bulleted lists; I feel like the learning / value of me demonstrating that I could build in those features is 
somewhat limited at this point, relative to the work it would take, and I REALLY didn't want to have to hand-code all of my notes into HTML.
Accordingly, I have nuked out my unit 1 notes, my footer, and my sweet image sidebar. I have also maintained the exact same CSS from project 1, and have not worried about
the fact that my HTML doesn't validate. Again, this is because the educational value of changing it is minimal relative to the work it would take to modify - I'll take pains
on my final project to make everything pretty and functional, but not here. Please also note my named, linked headers; I'm pretty proud of that. -->
<body>
	<<nav role = "navigation" class = "TOC">
			<h1>Main Topics</h1>
				<ul><li><a href = "#Object%20Oriented%20Programming">Object Oriented Programming</a></li><li><a href = "#What%20is%20an%20Object?">What is an Object?</a></li><li><a href = "#Why%20Object%20Oriented%20Programming?">Why Object Oriented Programming?</a></li><li><a href = "#Terminology">Terminology</a></li><li><a href = "#HTML%20and%20CSS%20Analogies">HTML and CSS Analogies</a></li><li><a href = "#Random%20Notes">Random Notes</a></li>		</ul>
		</nav>
        <div class = "info">
        <div class = "content">
			<div class = "body">
				<h2 id = "Object%20Oriented%20Programming">Object Oriented Programming</h2>
					<p> Object Oriented Programming, is, essentially, what it sounds like: Programming which is Oriented around the manipulation, variation, etc. of Objects.<br></p>
			</div>
		
			<div class = "body">
				<h2 id = "What%20is%20an%20Object?">What is an Object?</h2>
					<p> Basically everything in Python is an object. Classes are Objects, Instances of Classes are Objects, Functions are Objects.<br></p>
			</div>
		
			<div class = "body">
				<h2 id = "Why%20Object%20Oriented%20Programming?">Why Object Oriented Programming?</h2>
					<p> Two major reasons that make OOP useful are, from my perspective, the fact that code can be re-used, and the fact that it makes the program (once you get the hang of OOP) conceptually more easy to deal with.<br><br>People are used to thinking about objects, blueprints, and even sub-classes (eg. "what is the difference between a fish and a salmon"). There may be non-object oriented ways to program, and these ways may even result in code that is more efficient, more flexible, and easier to use. The problem is that, at the end of the day, human beings have to write, and therefore understand, the code. A day may (or probably already has) come where computers can write a large amount of code instead of people, in a way that makes sense to the computer. Even in this scenario, it falls to humans to validate the code they wrote to program the programming-computer; at some point, this may be done through scientific tests on the output, but for now it seems more likely to be successful if the code is human-readable, and part of human-readability is the ability of humans to understand, conceptually, what is going on. A programming style which turns abstract code into "objects" makes this a somewhat more managable task.<br><br>Additionally, when an instance is created, this allows the re-use, and easy editing of code. If a Class inheritance is correctly defined, the conceptual framework of the program is already laid out. If something goes wrong with the program, not a bug, but an issue with the way something is done or some data is stored, theoretically one change in one class could modify the entire program. Imagine, for example, that we had a program dealing with solar systems, we didn't have the technology to determine if planets had moons, and we had assumed that every planet had at least one moon, so we had set our Planet class (which may be a subclass of our SolarObjects class) to include (let's say) self.moons = True by default. At some point we learn that not all planets have moons, we would be able to either create a sub-class of planet which was moonless, or (probably better) change Planet.moons = None. One change would affect the entire program, though we would have to (somehow - maybe we'll learn this later) update or re-instance every Planet.<br></p>
			</div>
		
			<div class = "body">
				<h2 id = "Terminology">Terminology</h2>
					<p> (1) Object: a memory location that holds a value, and may be referenced by a modifier.<br><br>(2) Class: a standard type of object, sort of like a blueprint. In Python, each class's __init__ function defines the customization of class instances.<br><br>(3) Instance: a particular 'realization' of a Class (eg. the salmon named Mary is a an instance of the class Salmon)<br><br>(4) Method: a chunk of code that does something. These are often associated with classes, and are actions (each class may carry with it actions -- I may have seen these referred to as verbs now and again) which instances of the class may perform.<br><br>(5) Module and Library: I think these are somewhat overlapping concepts. A module is a python file containing code, and a Library is a collection of modules. Whether a single file.py could be considered a library, and how much code file.py might need to contain in order for that to be true is what creates the ambiguity in my mind. For example, arguably if I created several classes in one file.py, this may be a module but not a library, however if I took this same code and split it over multiple files.py this may suddenly become a library -- this seems like an absurdity and I therefore am inclined to reject it. As such, I am left without a clear delineation between a library and a module.<br><br>(6) Class Variable: Variables within a class that are not associated with a particular instance of that class (i.e. are not used in __init__). Presumably these would also include variables that are intentionally hidden within a class for security reasons (eg. bank balances hidden behind if statements)<br><br>(7) Inheritance: the ability to sub-class and automagically (not really, the call to the parent class must be explicit) pass pieces of the parent class to the child class.<br><br>(8) Method Overriding: the ability to override the method/instance variable of the parent class by giving it the same name in the child class.<br><br></p>
			</div>
		
			<div class = "body">
				<h2 id = "HTML%20and%20CSS%20Analogies">HTML and CSS Analogies</h2>
					<p> Basically, HTML inheritance with regard to styles works the same way as class inheritance in OOP. The more local variable with the same name (analagous to child classes) overrides the styling of the parent class. This gives OOP the same benefits as the CSS and HTML separation - DRY, easy maintenance, increased speed of programming, etc.<br></p>
			</div>
		
			<div class = "body">
				<h2 id = "Random%20Notes">Random Notes</h2>
					<p> Python Standard Library: Library that came with Python<br><br>Abstraction: hiding the detail of functions/programs<br><br>Python Shell: gives output of Python programs, and allows typing directly into it to see how certain bits of code work<br><br>Python libraries: os, webbrowser, time, turtle (draws things on screen - why is it called turtle?)<br>Python functions: webbrowser.open, time.ctime, time.sleep, os.listdir, os.rename, os.cwd [current working directory], turtle.Turtle, turtle.Screen<br>turtle.Turtle()<br>>> .forward()<br>>> .right()<br>>> .shape()<br>>> .color()<br>>> .speed()<br><br>turtle.Screen()<br>>> .bgcolor()<br>>> .exitonclick()<br><br><br>some_module.py<br>>> some_module.do_this<br>>> some_module.do_that<br><br>#nb: "self" as an argument is convention - doesn't do anything but increase readability... maybe?<br>class(Parent):<br>    def __init__(self, args):<br>        self.instance_variables = args<br><br>class Child(Parent):<br>    def __init__(self, args):<br>        Parent.__init__(values)<br>        self.instance_variables = args<br</p>
			</div>
		</div>
	 </div>
</body>